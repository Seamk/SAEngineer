# 第五章 系统设计

**本章概要**

>
> 处理流程设计
>
> 软件架构设计
>
> 结构化设计
>
> 面向对象设计
>
> 人机界面设计
>
> Web应用设计

## 一.处理流程设计

#### 1.1业务流程分析方法

- 价值链分析法
- 供应链分析法
- 客户关系分析法
- 基于ERP的分析法
- 业务流程重组

#### 1.2业务流程建模（Business Process Modeling）

1. 标杆瞄准
   - 确定研究对象（流程、因素）
   - 确定标杆对象（企业、组织、流程）
   - 采集数据、分析数据
   - 选的最佳标杆标准
   - 确定改进目标
   
2. IDEF
   - [集成化计算机辅助制造的定义方法(ICAM Definition Method)](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E5%88%B6%E9%80%A0%E5%AE%9A%E4%B9%89/20811468?fromtitle=IDEF&fromid=4673104)
   - 16种
   - 一系列建模、分析和仿真方法的统称
   
3. DEMO

   

4. 业务流程建模语言（BPML）
   - BPEL
   - BPML
   - BPMN
   - XPDL:XML流程定义语言

5. 基于Web服务的BPM
   - 基于Web服务的思想
   - 关键在于那些业务可以定义为服务
   - 原则：松散耦合，可复用

6. 业务流程重组(BPR)
   
- 重组目标：获得可以用关键指标（成本、质量、服务和建模）衡量显著性成就
  
7. 业务流程管理(BPM)
   - 以规范化的构造端到端的卓越业务流程为中心
   - 以持续的提高组织业务绩效为目的
   - 流程管理包括三个层面：流程规范、优化流程和再造流程

## 二.软件架构的概念

> 架构设计就是需求分配即：将满足需求的职责分配到组件上

- **实质**：软件架构为软件系统提供了一个结构、行为和属性的高级抽象
  - 由构成系统的元素的描述
  - 这些元素的相互作用
  - 指导元素集成的模式
  - 这些模式的约束组成。
- **作用**：
  - 软件架构是项目干系人进行交流的手段
  - 明确了对系统实现的约束条件，决定了开发和维护组织的组织结构
  - 制约着系统的质量属性

#### 2.1软件架构风格

- 架构设计的核心问题：
  - 能否达到架构级的软件复用

- 软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式
- **软件风格**定义一个系统家族，即：
  - 一个体系结构（软件架构）定义一个**词汇表**和一组**约束**
    - 词汇表：包含一些构件和连接件类型
    - 约束：指出系统如何将构件和连接件组合起来的
      - 约束需求=业务环境因素 + 使用环境因素 + 构建环境因素 + 技术环境因素

- 数据流风格
  - 批处理序列
  - 管道-处理器

- 调用/返回风格
  - 主程序/子程序
  - 面向对象
  - 层次结构

- 独立构件风格
  - 进程通信
  - 事件驱动系统（隐式调用）

- 虚拟机风格：
  - 解释器
  - 基于规则的系统

- 仓库风格
  - 数据库系统
  - 超文本系统
  - 黑板系统

## 三.结构化设计

**原则**：

- 保持模块大小适中
- 尽可能减少调用深度
- [多扇入少扇出](https://www.cnblogs.com/bnuvincent/p/6850403.html)
- 单入口，单出口
- 模块的作用域应该在模块之内
- 功能应该是可预测的

## 四.面向对象设计

#### 4.1基本过程

1. 分析模型

   - 用例模型
   - 分析模型

2. 设计师

   - 设计用例的实现方案

   - 设计技术支撑实施

   - 设计用户界面

   - 细化设计模型

3. **设计模型**（UML的使用）
   - 架构图（包图）
   - 用例实现图（交互图）
   - 类图（完整、精确）
   - 其他（状态图、活动图等）

#### 4.2设计原则

- [设计模式七大原则](https://blog.csdn.net/huachao1001/article/details/51536074)

#### 4.3设计模式的概念

**区别：**

- 架构模式：例如C/S
- 设计模式：与语言无关
- 惯用法：与语言有关，例如引用-计数是C++语言的惯用法

#### 4.4设计模式的分类

##### 创建型模式

![1584153826069](D:\GitHub\SAEngineer\SAEngineer\_static\1584153826069.png)

##### 结构型模式

![1584153913418](D:\GitHub\SAEngineer\SAEngineer\_static\1584153913418.png)

##### 行为型模式

![1584154474834](D:\GitHub\SAEngineer\SAEngineer\_static\1584154474834.png)

![1584154537638](D:\GitHub\SAEngineer\SAEngineer\_static\1584154537638.png)

## 五.人机界面设计

- 至于用户控制之下
  - 召之即来、来之能战、战之必胜
- 减少用户的记忆负担
  - 隐喻、渐进、缺省
- 保持界面一致性

## 六.Web应用设计

> 性能
>
> 安全性
>
> 可用性

#### 1、数据库与Web服务器的分离

- 旧：单台机器=web应用+数据库
- 新：**应用服务器**+**数据库服务器**

#### 2、应用服务器集群

- 多个应用服务器

**存在的问题：**

1. 用户的请求由**谁转发**到具体的应用服务器
2. 用户如果每次访问到服务器不一样，那么**如何维护[session（会话）的一致性](https://www.w3cschool.cn/architectroad/architectroad-session-consistency.html)**

#### 3、应用服务器方面

- 问题1：负载均衡技术

  - 方式：应用层（1/2）/传输层(3/4)/混合负载均衡

    1. http重定向：应用层请求转发；**实现**简单，但是性能差

    2. 反向代理服务器，例如apache，nginx（[前端缓存最佳实践](https://juejin.im/post/5c136bd16fb9a049d37efc47)）；**部署**简单，但是性能存在瓶颈
    3. DNS域名解析负载均衡，直接获取域名对应的IP地址；效率比1高，但是不够灵活
    4. 基于[NAT](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)的负载均衡；技术成熟，但是NAT也让主机之间的通信变得复杂，导致了通信效率的降低

  - 算法：静态、动态（运行时）

- 问题2：有状态与无状态

  - 客户端[cookie](https://zh.wikipedia.org/wiki/Cookie)：服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。
  - 服务端：1.在负载均衡系统中可以通过共享储存或者设立独立的存储服务器来解决；2.使用缓存存储会话数据是一种不需要储存介质的解决方案。

  - 无状态服务：处理一次请求所需的全部信息（答案），要么都包含在次请求里，要么可从外部（数据库）获取。
  - 有状态服务：与无状态相反

---

#### 4、数据库服务器方面

- 数据库读写分离化
  - **主**库写**入**
  - **从**库读**出**
  - 主、从库同步

- 用缓存缓解读库的压力
  - [Guava、Memcached 和 Redis，我们为什么选择了 Redis？](https://juejin.im/post/5deef9cbf265da33d56d1761)

- CDN：Content Delivery Network(内容分发网络)
  - [趣讲CDN](https://juejin.im/post/5c188d06f265da615114acb0)

